/*
    MIT License

    Copyright (c) 2025, maniek86 (Piotr Grzesik)

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
*/

// 
// FPGA bitstream loader & reset circuit handler for the M8SBC-486 homebrew computer project
//


#include <avr/io.h>
#include <util/delay.h>
#include <avr/pgmspace.h>
#include <stdint.h>

// from bitstream.S, generated by Makefile
extern const uint8_t bitstream[] PROGMEM;
extern const uint8_t bitstream_end[] PROGMEM;

// Helper macro: get 32-bit flash address of a symbol
#ifndef pgm_get_far_address
#define pgm_get_far_address(var) ((uint32_t)(&(var)))
#endif


#define FPGA_PROG_PORT PORTE
#define FPGA_PROG_DDR  DDRE
#define FPGA_PROG_BIT  PE5   // PROG_B, output

#define FPGA_INIT_PIN  PINE
#define FPGA_INIT_BIT  PE6   // INIT_B, input

#define FPGA_DONE_PIN  PINE
#define FPGA_DONE_BIT  PE4   // DONE, input

#define RESET_OUT_PORT PORTF
#define RESET_OUT_DDR  DDRF
#define RESET_OUT_BIT  PF0   // RESET_OUT, output, active high

#define FPGA_REQ_PIN   PINF
#define FPGA_REQ_BIT   PF1   // FPGA_REQ_RESET input, active low

#define RESET_BTN_PIN  PINB
#define RESET_BTN_BIT  PB4   // RESET_BTN, input, active low

// SPI pins: PB1 - SCK (CCLK), PB2 - MOSI (DIN)
#define SPI_DDR  DDRB
#define SPI_PORT PORTB

// UART1 debug (PD3 TX1, PD2 RX1)
static void uart1_init(unsigned long baud) {
    uint16_t ubrr = (uint16_t)((F_CPU/16/baud) - 1);
    UBRR1H = (uint8_t)(ubrr >> 8);
    UBRR1L = (uint8_t)(ubrr & 0xFF);
    UCSR1A = 0;
    UCSR1B = (1<<TXEN1); // TX only for debug
    UCSR1C = (1<<UCSZ11) | (1<<UCSZ10); // 8N1
}

static void uart1_putc(char c) {
    while (!(UCSR1A & (1<<UDRE1)));
    UDR1 = (uint8_t)c;
}

// SPI init (master, SPI2X: f_osc/2, at 16 MHz = 8MHz SCK)
static void spi_init_fast(void) {
    SPI_DDR |= (1<<PB1) | (1<<PB2) | (1<<PB0); // SCK, MOSI, SS as outputs
    SPI_PORT |= (1<<PB0); // keep SS high (inactive)
    SPCR = (1<<SPE) | (1<<MSTR); // enable SPI, master, def mode 0
    SPSR |= (1<<SPI2X); // fosc/2 
}

// SPI send
static inline void spi_write_byte(uint8_t b) {
    SPDR = b;
    while (!(SPSR & (1<<SPIF)));
}

// Assert reset and delay
static void assert_reset_output_ms(uint16_t ms) {
    RESET_OUT_PORT |= (1<<RESET_OUT_BIT);
    while (ms >= 10) { _delay_ms(10); ms -= 10; }
    while (ms--) _delay_ms(1);
}

// Catch reset requests: FPGA reset (PF1 low) or button (PB4 low)
static uint8_t reset_requested(void) {
    if (!(PINF & (1<<FPGA_REQ_BIT))) return 1;
    if (!(PINB & (1<<RESET_BTN_BIT))) return 1;
    return 0;
}


static uint32_t bitstream_length(void) {
    return pgm_get_far_address(bitstream_end) - pgm_get_far_address(bitstream);
}

static void uart1_puthex_nibble(uint8_t nib) {
    nib &= 0xF;
    if (nib < 10)
        uart1_putc('0' + nib);
    else
        uart1_putc('A' + (nib - 10));
}

// helper: send 32-bit value as 8 hex digits
static void uart1_puthex32(uint32_t val) {
    for (int i = 28; i >= 0; i -= 4) {
        uart1_puthex_nibble((val >> i) & 0xF);
    }
}


// Load bitstream from flash into FPGA
int load_fpga_from_flash(void) {
    uint32_t start_addr = pgm_get_far_address(bitstream);
    uint32_t len = bitstream_length();

    spi_init_fast();

    FPGA_PROG_DDR |= (1<<FPGA_PROG_BIT); // PROG_B output
    
    // Pulse PROG_B
    FPGA_PROG_PORT &= ~(1<<FPGA_PROG_BIT); // low
    _delay_us(1000);
    FPGA_PROG_PORT |= (1<<FPGA_PROG_BIT);  // high
    _delay_us(5000);

    // wait for INIT_B to go high with simple timeout
    unsigned long timeout = 1000000UL;
    while (!(FPGA_INIT_PIN & (1<<FPGA_INIT_BIT))) {
        if (!--timeout) { uart1_putc('I'); return -1; }
    }

   
    // Send bitstream + print checksum 
     
    uint32_t checksum = 0;
    
    for (uint32_t i = 0; i < len; i++) {
        uint8_t b = pgm_read_byte_far(start_addr + i);
        checksum += b;
        spi_write_byte(b);
    }
    
    uart1_putc('\r');
    uart1_putc('\n');
    uart1_puthex32(checksum);
    uart1_putc('\r');
    uart1_putc('\n');
    _delay_us(5000);

    // Check done
    if (FPGA_DONE_PIN & (1<<FPGA_DONE_BIT)) { // high
        uart1_putc('D'); // OK
        return 0;
    } else { // low
        uart1_putc('E'); // Error
        return -2;
    }
}

int main(void) {
   
    DDRF &= ~(1<<FPGA_REQ_BIT);
    PORTF |= (1<<FPGA_REQ_BIT);
    DDRB &= ~(1<<RESET_BTN_BIT);
    PORTB |= (1<<RESET_BTN_BIT);
    DDRE &= ~((1<<PE4)|(1<<PE6));     // INIT and DONE inputs
    RESET_OUT_DDR |= (1<<RESET_OUT_BIT);    // Reset out
    
    RESET_OUT_PORT |= (1<<RESET_OUT_BIT); // RESET ON

    uart1_init(9600);
    uart1_putc('S'); // start

    // Load bitstream into FPGA
    if (load_fpga_from_flash() == 0) {
        // Success, hold reset for 300ms
        _delay_ms(300);
        RESET_OUT_PORT &= ~(1<<RESET_OUT_BIT); // release
    } else {
        // Fail, hold reset
        RESET_OUT_PORT |= (1<<RESET_OUT_BIT);
    }
    

    while(1) {
        if (reset_requested()) {
            
            assert_reset_output_ms(500);
            if(reset_requested()) continue; // if still held
            
            uart1_putc('R');            
            RESET_OUT_PORT &= ~(1<<RESET_OUT_BIT); /* release */
        }
        _delay_ms(50);
    }

    return 0;
}

